% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{在}{本书第一部分}我说范畴论和编程都是关于组合的. 在编程中, 你不断分解一个问题
直到你可以处理的小问题, 解决每个小问题, 然后自底向上重新组合出你的程序. 粗略说有两种办法做到这一点:
告诉计算机做什么, 或者告诉计算机怎么做. 前者叫做声明式的, 后者叫做命令式的.

你可以在最基本的层级看到这个. 组合本身可以声明式定义; 正如 \code{h} 是 \code{f} 和其之前的 \code{g} 二者组合:

\src{snippet01}
也可以命令式; 正如, 先调用 \code{f}, 记住结果, 然后用那个结果调用 \code{g}:

\src{snippet02}
程序的命令式版本通常描述为按照时间顺序执行的行动序列. 在这个例子里, 调用 \code{g} 必须在 \code{f} 执行完成之后才能发生.
至少理论上是这样 --- 在惰性求值的语言里, 用 \emph{按需求值} 传参, 实际执行可能会有所不同.

其实, 取决于编译器的智慧程度, 声明式和命令式代码的执行可能没有什么区别. 但是这两种方法在我们解决问题的方式上有很大的不同,
在结果代码的维护成本和测试能力方面也很不一样.

主要问题是: 面对一个问题的时候, 我们总可以选择用两种方式的一种来解决它吗? 如果有一个声明式的解法, 它总可以翻译成计算机代码吗?
这个问题的答案一点也不显然, 如果我们能找到它, 我们对宇宙的看法也许会根本改变.

\begin{wrapfigure}{R}{0pt}
  \includegraphics[width=0.5\textwidth]{images/asteroids.png}
\end{wrapfigure}

让我稍微解释一下. 物理中有一个类似的二元性, 它要么指向一些深层的基本原理, 要么告诉我们一些关于我们思维方式的东西.
理查德·费曼提过这个二元性, 它激励了在量子电动力学上的工作.

大多数物理定律有两种表达形式. 一种使用局部的, 或者说无穷小的观点. 我们看一个系统在一个小邻域的状态, 然后预测它在下一个瞬间的演化.
这通常用微分方程来表达, 它们必须在一段时间内被积分, 或者说求和.

注意这个方法多像命令式的观点: 我们通过一系列小小的步骤来到达最终答案, 每个小结果取决于之前的结果. 实际上, 计算机模拟的物理系统
通常就是这样实现的, 它们把微分方程转换成差分方程, 然后迭代它们. 这也是在小行星游戏中实现飞船动画的方法. 在每个时间步长, 飞船的位置
都稍微改变一点. 改变多少用速度和时间算出来. 速度又用加速度算出来, 加速度是力除以质量.

那里直接编码了牛顿运动定律的微分方程:
\begin{align*}
  F & = m \frac{dv}{dt} \\
  v & = \frac{dx}{dt}
\end{align*}
相似的方法用作更复杂的问题, 例如使用麦克斯韦方程来传播电磁场, 或者甚至是用格点 \acronym{QCD} (量子色动力学)
来描述质子内部的夸克和胶子的行为.

这个局部思维方式, 加上电子计算机带来的时空离散化, 最能彰显在 Stephen Wolfram 英雄式的尝试中. 他把整个宇宙的
复杂性缩减成一组细胞自动机的系统.

另一种方式是全局的. 我们看系统的初始状态和最终状态, 然后求一个函数的最小值来计算连接两个状态的轨迹. 最简单的例子是
费马最短时间原理. 它说光线沿着最短的路径传播. 特别地, 在没有反射或者折射的情况下, 从点 $A$ 到点 $B$ 的光线会走最短的路径,
也就是一条直线. 但是光在密集的(透明)材料中传播得更慢, 比如水或者玻璃. 所以如果你在空气中选一个起点, 在水下选一个终点,
光线会更愿意在空气中多走一点, 然后在水中走一条捷径. 最短时间的路径会让光线在空气和水的边界处折射, 从而得到折射定律:
\begin{equation*}
  \frac{sin(\theta_1)}{sin(\theta_2)} = \frac{v_1}{v_2}
\end{equation*}
这里 $v_1$ 是空气中的光速, $v_2$ 是水中的光速.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/snell.jpg}
\end{figure}

\noindent
所有经典力学都可以从最小作用量原理推导出来. 任何轨迹的作用量都可以通过积分拉格朗日量来计算, 拉格朗日量是动能和势能的差值
(注意: 是差值, 不是和 --- 和是总能量). 当你发射迫击炮打一个目标的时候, 炮弹会先向上飞, 那里重力势能更高, 然后花一些时间
在那里, 为作用量贡献负值. 它也会在抛物线的顶点减速, 以最小化动能. 然后它会加速, 快速穿过势能较低的区域.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/mortar.jpg}
\end{figure}

\noindent
费曼最伟大的贡献是意识到最小作用量原理可以推广到量子力学. 在那里, 再一次, 问题被表述为初始状态和最终状态. 在这两个状态
之间的费曼路径积分被用来计算转变的概率.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/feynman.jpg}
\end{figure}

\noindent
重点是我们表达物理学定律的方式有两种. 我们可以用局部的方式, 那里事情逐步发生, 每次一点点. 或者我们可以用整体的观点.
那里我们就声明开始和最后的条件, 其间的一切都会自动发生.

这里的全局方法同样可以应用到编程中, 例如实现光线追踪的时候. 我们声明眼睛的位置, 还有光源的位置, 找出光线连接它们的路线.
我们不显式最小化每条光线的传播时间, 但是我们用斯涅尔定律和反射的几何性质来达到同样的效果.

局部和整体观点的最大差异在于对时间和空间的不同处理方式. 局部方法接受当下的满足, 而整体方法则是长期的静态观点, 就好像未来
已经被预定, 我们只是在分析某个永恒的宇宙的性质.

这种思想在函数响应式编程 (\acronym{FRP}) 中最能体现. 与其为每个可能的用户操作写一个单独的处理器, 然后让这些处理器都
访问共享可变状态, \acronym{FRP} 把外部事件当成一个无限的列表, 然后对它应用一系列变换. 理论上, 我们程序的所有未来的行动
都在那里, 就是程序的输入数据. 从程序的眼光, $\pi$ 的数字列表, 伪随机数列表, 或者鼠标位置列表都没有区别. 在每种情况下,
如果你想要第 $n$ 个元素, 你必须先处理前 $n-1$ 个元素. 当应用到时间事件的时候, 我们称这个性质为 \emph{因果性}.

所以这和范畴论有什么关系? 我会说范畴论鼓励一种全局的眼光, 因此支持声明式编程. 首先, 不像微积分, 它没有内置的距离概念,
或者邻域, 或者时间. 我们只有抽象的对象和抽象的连接它们的方式. 如果你能通过一系列步骤从 $A$ 到 $B$, 你也可以一步到位.
此外, 范畴论的主要工具是普遍构造, 它是全局方法的典范. 我们在定义范畴积的时候看到了它. 它是通过指定它的性质来定义的 --- 一个
非常声明式的办法. 它是一个有两个投影的物件, 而且是这些物件中最好的那个 --- 它优化了某个性质: 因子化其他这样物件的投影.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/productranking.jpg}
\end{figure}

\noindent
对比这个和费马最短时间原理, 或者最小作用量原理.

反过来, 把这个和笛卡尔积的传统定义对比, 它更加命令式. 你描述了怎么从一个集合中选一个元素, 然后从另一个集合中选一个元素,
然后把它们组合成一个元素. 这是一个创建对的配方. 还有一个配方用来拆分一个对.

在几乎每个编程语言, 包括像 Haskell 这样的函数式语言里, 积, 和, 函数类型都是内置的, 而不是通过普遍构造定义的; 尽管有人
尝试过创建范畴编程语言 (见 \urlref{Tatsuya Hagino 的论文}{http://web.sfc.keio.ac.jp/~hagino/thesis.pdf}).

不管有没有直接使用, 范畴定义都合理化了现存的编程构造, 并且催生新的. 最重要的是, 范畴论为在声明式层级上推理程序提供了
元语言. 它也鼓励在代码之前先推理问题的规约.
