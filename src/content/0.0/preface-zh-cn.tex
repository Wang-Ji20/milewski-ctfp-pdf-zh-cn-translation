% !TEX root = ../../ctfp-print.tex

\begin{quote}
  很久以来我一直想写一本书, 讲的是范畴论, 讲给程序员听. 注意, 不是计算机科学家, 而是程序员——
  他们是工程师而不是科学家. 听上去很吓人, 我也怕写不好. 科学和工程区别很大, 我当然知道,
  因为我在两边都工作过. 但我很想把事情解释清楚. 我崇拜理查德·费曼\(Richard\ Feynman\),
  他是大师, 简单几句就能把事情讲明白. 我知道我不是费曼, 不过我要努力. 开始之际, 我
  写这篇序言来鼓励读者学习范畴论, 希望引起讨论并激发反馈. \footnote{
    你也许想看看我的视频课程, 在
    \href{https://goo.gl/GT2UWU}{https://goo.gl/GT2UWU} (或者在 Youtube 搜索
    ``bartosz milewski category theory'')}
\end{quote}

\lettrine[lhang=0.17]{我}{要} 用几个段落说服你：这书是写给你的. 学习数学中最
抽象的领域要花费 ``大量空闲时间'', 你也许会这样反对我, 但你的担忧毫无根据.

我那么乐观, 基于以下原因. 首先, 范畴论是一座宝库, 其中含有非常实用的编程思想. Haskell
程序员已经利用这些资源很久了, 这些思想也渗透到其他编程语言里, 但渗透得很慢. 我们需要
加快速度.

第二, 有很多种数学, 它们吸引不同的人. 你也许讨厌微积分或线性代数, 但你不见得讨厌范畴论.
我要说, 范畴论是最适合程序员的数学. 这是因为范畴论研究的对象不是具体的东西, 而是结构；
这种结构让程序可以组合.

组合是范畴论的精髓, 范畴的定义中就含有组合. 我要说组合就是编程的本质. 我们
一直在组装东西, 先驱还没有发明子过程时, 我们就在组合. 很久以前, 结构化编程革新了编程,
因为它们让代码分成块, 这些块相互组合. 然后面向对象出现, 它组合对象. 函数式编程
不仅能组合函数和代数数据结构, --- 它还可以组合并发 ---, 这个功能其他编程范式都做不了.

第三, 我有一件秘密武器, 一把屠刀. 我会把数学砍到能被程序员理解. 如果你是一名数学家, 你
要非常小心, 弄对每一个假设, 准确限定每一个语句, 严格构造证明. 所以门外汉很难读懂数学书和
数学论文. 我是学物理的, 在物理中我们广泛应用非形式推理. 数学家嘲笑狄拉克 delta 函数, 它
由伟大的物理学家 P.A.M Dirac 用来解一些微分方程. 他们后来笑不出来了, 因为发现了一门新的
微积分分支——分布理论, 它形式化了 Dirac 的洞见.

不过用通俗的话讲数学, 有可能完全讲错了；所以我会确保书中所有的非正式结论背后都有严格的数学基础.
我真有一本 Saunders Mac Lane 的 \emph{Categories for the Working Mathematician}
在床头柜上.

因为这是 \emph{给程序员} 的范畴论, 我会用代码解释所有的重要概念. 你也许会发现, 比起常用的
命令式编程语言, 函数式编程语言更像数学一些. 函数式语言还有更强的抽象本领. 所以自然会开始想：
也许要先学习 Haskell 才能学明白范畴论. 这意味着范畴论只能用在函数式编程里, 所以是错的.
我会写大量的 C++ 例子. 你一定会看到一些丑陋的语法, 代码不会非常可读；你也许要多次复制粘贴,
来弥补 C++ 缺少的高层抽象能力, 但这也不过是普通 C++ 程序员每天都在做的事情.

提到 Haskell 的时候, 你也不必茫然无措. 你不需要成为 Haskell 程序员, 你只需要一门语言, 用来
勾画思想, 便于你在 C++ 中实现这些想法. 这其实也是我当初学习 Haskell 的契机. 我发现它语法精简,
类型系统很强大, 非常适合用来理解和实现 C++ 模板、数据结构和算法. 但我不能指望人人学过 Haskell,
所以我会在这本书中慢慢介绍一切.

如果你是老程序员, 你一定扪心自问：我已经写这么久代码了, 从来没见过范畴论或者函数式, 世界变了？
当然, 你惯用的命令式语言中已经侵入了大量的函数式特性. 甚至 lambda 表达式都闯入了 OOP 最
坚实的堡垒, Java 语言中. C++ 语言这几年同样飞速演化 --- 几年一个新标准 ---, 想要跟上
时代. 所有这些都在导向一个突变, 或者我们学物理的叫做相变. 煮热水总会沸腾. 我们正是一只在温水
里的青蛙, 需要决定是继续呆在水里, 还是离开呢？

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/img_1299.jpg}
\end{figure}

\noindent

巨变之一是多核革命. 流行的 OOP 在并发和并行编程领域毫无作用, 反而容易产出危险和漏洞百出
的设计. 数据隐藏是 OO 的基本前提, 但它只要加上共享和互斥, 就成为数据竞争的温床. 用
互斥锁保护代码看上去很好, 但是锁不能组合, 而且把锁藏起来的话, 更容易死锁, 而且更难 Debug.

即使不说并发, 软件系统越来越复杂, 其规模效应也让命令式编程范式无法应付. 简单说, 副作用
已经控制不住了. 确实, 有副作用的函数很方便, 写起来也很容易. 他们的效果写在名字和注释里.
叫做 SetPassword 或 WriteFile 的函数显然改变一些状态, 并产生一些副作用, 我们习惯
处理这些. 但组合这些函数之后, 副作用发生在有副作用的函数之上, 情况就变得极其
复杂. 不是说副作用绝对不好, 只是它们隐藏起来, 所以在规模很大的时候没有办法管理. 副作用
不能规模化, 而命令式编程基本都是副作用.

硬件改变, 软件越来越复杂, 所以我们要重新思考编程的基础. 就像那些建造欧洲伟大的哥特教堂
的建筑师, 我们磨练自己的工艺, 直到材料和结构的极限. 有一个未完成的哥特教堂矗立在法国,
\urlref{http://en.wikipedia.org/wiki/Beauvais_Cathedral}{Beauvais},
凝视着人们追求极致的努力. 它本来要用来打破所有之前的高度和亮度记录, 但倒塌了好几次.
临时措施, 例如铁棍和木撑虽然让它免于解体, 但无疑很多东西大错特错. 从现代观点看, 那么多
哥特建筑建成, 完全不借助现代材料科学、计算机建模、有限元分析、数学、物理, 堪称奇迹.
我希望未来的人们看到我们在操作系统、网络服务器、互联网上展现的编程技巧, 会同样惊讶.
而且, 他们理应惊讶, 因为我们做这些都只在脆弱的理论基础上. 如果我们要前进就必须巩固
这些基础.

\begin{figure}
  \centering
  \includegraphics[totalheight=0.5\textheight]{images/beauvais_interior_supports.jpg}
  \caption{临时措施, 用来避免 Beauvais 大教堂倒塌. }
\end{figure}
