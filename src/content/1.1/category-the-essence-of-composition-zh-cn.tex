% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{范畴} 是一个简单到令人尴尬的概念.范畴由 \newterm{物件}
和物件之间的 \newterm{箭头} 组成.这让范畴很容易用图片来表示.物件可以用圆圈或者点表示,
而箭头 \ldots{} 就是箭头.(我常常会把物件画成小猪,把箭头画成烟花.) 但是范畴的本质是\emph{组合},
或者反过来说,组合的本质是范畴,看你喜欢怎么说.箭头可以组合,所以如果你有一个箭头从物件 $A$ 指向物件 $B$,
另一个箭头从物件 $B$ 指向物件 $C$,那么一定有一个箭头 --- 也就是两个箭头的组合 --- 从 $A$ 指向 $C$.

\begin{figure}
  \centering
  \includegraphics[width=0.8\textwidth]{images/img_1330.jpg}
  \caption{在范畴中,如果有一个箭头从 $A$ 指向 $B$, 另一个箭头从 $B$ 指向 $C$, 那么从 $A$ 到 $C$ 也必然
  有一个箭头,代表它们的组合. 这张图还不完整,缺少单位态射(后面说).}
\end{figure}

\section{箭头是函数}

是不是已经太多抽象的胡说八道? 不要绝望. 让我们说说具体的东西. 想一想箭头, 他们也叫做态射, 它们
只是函数. 你有一个函数 $f$ 接受参数类型为 $A$ 返回 $B$. 你有另一个函数 $g$ 接受参数类型 $B$, 然后
返回类型 $C$. 把 $f$ 的结果给 $g$, 你就把这两个函数组合了起来, 一个 接受类型 $A$ 返回 $C$ 的函数.

在数学里, 函数组合用函数间的小圆圈表达: $g \circ f$. 注意顺序是从右边到左边. 一些人觉得不太舒服,
或许你比较熟悉 UNIX 中的管道记号, 这样:

\begin{snip}{text}
lsof | grep Chrome
\end{snip}
或者 F\# 中的波浪符号 \code{>>}, 这也是从左边到右边的. 但是数学和 Haskell 函数组合从右到左.
你可以把 $g \circ f$ 读成 ``g 之前 f.''

我们写一点 C 语言代码继续说明. 函数 \code{f} 接受类型 \code{A} 返回类型 \code{B}:

\begin{snip}{text}
B f(A a);
\end{snip}
另一个:

\begin{snip}{text}
C g(B b);
\end{snip}
它们组合起来是:

\begin{snip}{text}
C g_after_f(A a)
{
    return g(f(a));
}
\end{snip}
这里你又见到了从右到左的组合: \code{g(f(a))}; 这次是 C 语言.

我希望能告诉你 C++ 有一个模板函数, 接受两个函数, 返回它们的组合. 但是没有. 所以
我们来试试 Haskell. 这里声明了一个函数, 从 A 到 B.
\src{snippet01}
与之类似

\src{snippet02}
组合是:

\src{snippet03}
看 Haskell 如此简单, C++ 就更加尴尬: 无法表达直白的函数概念. 实际上, Haskell 让你
用 Unicode 字符, 所以可以这样写组合:
\begin{snip}{text}
g ◦ f
\end{snip}

你甚至还能写 Unicode 双冒号和箭头:
% don't 'mathify' this block
\begin{snipv}
f \ensuremath{\Colon} A → B
\end{snipv}

Haskell 第一课: 双冒号代表 ``类型为 \ldots{}.'' 在两个类型中间插入箭头, 就得到了函数
类型. 在两个函数中间加入句号(或者 Unicode 圆圈)就可以把它们组合起来.

\section{组合的性质}

有两个非常重要的性质. 这两个性质范畴中的每一个组合都需要满足.
\begin{enumerate}
  \item
        组合服从结合律. 如果你有三个态射 $f$, $g$, 和 $h$, 它们可以组合起来(也就是说,
        它们的类型是匹配的), 这时不需要在它们中间加入括号. 用数学语言来表达:
        \[h \circ (g \circ f) = (h \circ g) \circ f = h \circ g \circ f\]
        用(伪) Haskell:

        \src{snippet04}[b]
        (我说伪, 是因为没有函数相等的定义)

        结合律对函数来说很显然, 但对其他范畴不一定这么显然.

        \item
        对每一个物件 $A$, 有一个箭头代表单位组合. 这个箭头从物件指向自身. 单位组合意味着
        它和每一个开始于 $A$ 或者结束于 $A$ 的箭头复合之后, 都得到同样的箭头. 物件 A 的
        单位箭头叫做 $\idarrow[A]$ (\newterm{identity} on $A$). 用数学语言来表达:
        若 $f$ 从 $A$ 到 $B$ 那么
        \[f \circ \idarrow[A] = f\]
        而且
        \[\idarrow[B] \circ f = f\]
\end{enumerate}

对函数来说, 单位箭头实现为一个单位函数, 它简单返回参数. 这个实现对每个类型都一样, 称
这个函数是通用多态的. 在 C++ 中我们用来模板定义:

\begin{snip}{cpp}
template<class T> T id(T x) { return x; }
\end{snip}

当然, C++ 没那么简单. 你不仅要考虑传什么参数, 你还要考虑如何传参(传值, 传引用, 传常量引用, 还是移动...)

在 Haskell 里, 单位函数是标准库(叫做 Prelude)的一部分. 下面是其声明和定义:

\src{snippet05}

如你所见, 多态函数在 Haskell 中很简单. 在声明中, 你只需要把类型替换成类型变量. 秘诀:
具体类型的名字开头总是用大写字母, 类型变量的名字开头总是用小写字母. 所以在这 \code{a}
代表所有的类型.

Haskell 函数定义由函数和其形式参数组成, --- 这里只有一个形参 \code{x}. 等号后面是函数体.
这种定义方式非常紧凑, 初学者可能有些震惊, 但你很快就能发现它自有道理. 函数定义和函数调用
是函数式编程中的衣食父母, 所以它们的语法自然剥皮见骨. 参数列表不仅没有括号包围, 甚至不用
逗号分割参数(后面我们定义多参数函数的时候, 你会看到这个).

函数体总是一个表达式 --- 函数中没有语句. 函数的结果就是一个表达式, 在这里就是\code{x}.

Haskell 第二课到此为止.

单位条件可以写为(继续用伪 Haskell):

\src{snippet06}
你也许会问: 单位函数有什么用 --- 它什么都不做啊? 如此说来, 为什么要数字 0 呢? 0 这个符号代表
什么都没有啊. 古罗马人的数字系统中没有 0, 他们依然可以建造优秀的道路和水道, 不少留存到今天.

涉及符号变量的时候, 像 0 或者 $\id$ 这样的中性值是非常有用的. 所以罗马人不擅长代数;
而阿拉伯人和波斯人擅长, 因为它们熟悉 0 的概念. 单位函数可以作为高阶函数的参数或者返回值,
这时非常便利. 高阶函数可以符号化地操纵函数, 它们是函数的代数学.

总结: 范畴由物件和箭头(态射)组成. 箭头可以组合起来, 组合符合结合律. 每个物件都有一个单位
箭头, 作为组合的单位元.

\section{组合是编程的本质}

函数式程序员思考问题的方式很怪. 他们开始的时候会问一些非常禅意的问题. 例如, 设计互动程序
的时候, 他们会问: 什么是互动? 实现 Conway 的 Game of Life 的时候, 他们思考人生的意义.
在这里我要问: 什么是编程? 第一个答案: 编程就是告诉计算机做什么. ``把内存地址 x 的内容加到寄存器 EAX 上''
但就算我们用汇编编程, 写给计算机的指令也表达了更丰富的内容. 我们在解决一个不平凡的问题
(如果是平凡的问题, 根本不需要计算机). 我们如何解决问题? 我们把大问题分解成小问题. 如果小问题
依然太大, 我们继续分解, 以此类推. 最终, 我们写程序解决小问题. 从这得到编程的本质: 我们
组合这些小代码块, 形成大问题的解. 如果我们不拼回去的话, 分解问题是没有意义的.

这个层次化的分解组合过程不是计算机的要求, 而是来自人类局限的心智. 大脑一次只能处理几个概念.
一篇心理学广泛被引的论文, \urlref{http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two}
{The Magical Number Seven, Plus or Minus Two}, 提出我们只能在脑海中保存 $7 \pm 2$
``块'' 信息. 对短期记忆的研究细节也许会变化, 但它总归是有限的. 底线是我们不能处理熬成汤一样粘稠
的对象, 或者像意大利面一样缠绕的代码. 我们需要结构, 不仅因为结构优秀的代码赏心悦目, 还因为
大脑无法有效处理它们. 我们常说一些代码优雅或者漂亮, 实际在说那段代码便于我们有限的心智理解.
优雅的代码创作恰当大小的块, 其数量也恰当到容易被我们的心理消化系统吸收.

所以组合程序时,什么才是合适的块? 它们的面积要比体积增长更慢. (我喜欢这个比喻, 因为几何上一个物件
的面积以平方增长, 而体积以立方增长, 所以面积增长比体积慢.) 面积是我们组合时所需的信息,体积是我们
实现功能所需的信息. 一块程序实现之后, 我们可以完全忘记它的实现细节, 专注于它如何同其他块的交互.
在 OOP 中, 这个表面是对象的声明, 或者抽象接口. 在函数式编程中, 它是函数声明.(我稍微简化了一些, 但这是核心思想.)

在这方面范畴论很极端, 因为它不让我们看物件的内部. 物件在范畴论中是一个抽象的实体. 你只知道它
同其他物件之间的关系 --- 它们如何用箭头连接. 这也是互联网搜索引擎排列网页的办法, 它们分析来去
的链接(除了作弊的情况). 在 OOP, 理想的对象只有接口可见(纯面积, 无体积), 用方法作为箭头. 如果
你要看对象内部, 才能明白对象如何用于组装, 你就已经失去了编程范式的好处.

\section{挑战}

\begin{enumerate}
  \tightlist
  \item
        尽你所能, 在你最喜欢的语言(haskell 除外)里实现一个单位函数.
  \item
        用你最喜欢的语言实现组合函数. 它接受两个函数, 返回其组合.
  \item
        写一个程序说明你的组合函数可以接受单位函数.
  \item
        互联网是一个范畴吗? 链接是态射吗?
  \item
        Facebook 是范畴吗? 其中的人是物件, 友谊是态射.
  \item
        有向图什么时候是范畴?
\end{enumerate}
