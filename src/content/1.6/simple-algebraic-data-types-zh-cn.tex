% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{学}{过两种} 组合类型的方法: 积和余积. 日常编程中我们可以用这两种
方法建造出大量的数据结构. 这有重要的实践意义. 许多数据结构的性质是可组合的. 例如, 如果你知道
如何判等基本数据类型, 你就知道如何把比较推广到积类型和余积类型里来. 在 Haskell 你可以
为大量组合类型自动衍生判等, 比较, 字符串转换等更多功能.

我们仔细看看编程中的积类型与和类型.

\section{积类型}

编程语言里, 两类型积的经典实现就是对. 在 Haskell 里, 对是一个原类型构造子; 在 C++ 里, 它是
标准库里一个相当复杂的模板.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/pair.jpg}
\end{figure}

\noindent
对不是严格可交换的: 一个对 \code{(Int, Bool)} 不能替换另一个对 \code{(Bool, Int)}, 即使它们
有相同的信息. 不过在同构意义上, 它们是可交换的. \code{swap} 函数给出这个同构(它是自己的逆):

\src{snippet01}
你可以认为这两个对不过用不同的格式存储同样的信息. 就像大端序和小端序一样.

可以把任意数量的类型组合成积类型, 只要把对嵌套在对里. 但是有更简单的方法: 嵌套对是等价于元组的.
因为其实不同的对嵌套方式是同构的. 如果你想把三个类型 \code{a}, \code{b}, 和 \code{c} 按刚才的顺序
组合成积, 可以有两种做法:

\src{snippet02}

或者
\src{snippet03}
这些类型不同 --- 你不能把一个传给需要另一个的函数 --- 但是它们的元素一一对应. 有一个函数把它们
映射起来:

\src{snippet04}
这个函数是可逆的:

\src{snippet05}
所以这是一个同构. 只是有不同重新打包信息的方法.

你可以把创建积类型的过程看作是类型的二元运算. 从这个角度看, 上面的同构就像幺半群的结合律:
\[(a * b) * c = a * (b * c)\]
除了在幺半群的情况下, 两种组合积的方式是相等的; 而在这里只是 ``同构意义上'' 相等的.

如果我们只看同构, 不去管严格相等, 我们可以更进一步, 说明单元类型 \code{()} 是积类型的单位元,
就像 1 是乘法的单位元. 确实, 一个值和单元类型配对不会增加任何信息. 这类型:

\src{snippet06}
与 \code{a} 同构. 下面是同构:

\src{snippet07}

\src{snippet08}
这些观察可以形式化为说 $\Set$ (集合范畴) 是一个\newterm{monidal category 幺半范畴}. 它是一个范畴,
也是一个幺半群, 你可以把对象相乘 (这里是取笛卡尔积). 我会在后面讲更多关于幺半范畴的内容, 并给出完整定义.

Haskell 中定义积类型还有一种更一般的方法 --- 特别是当它们和和类型结合时. 它用多参数的具名构造子. 例如对
也可以这样定义:

\src{snippet09}
这里 \code{Pair a b} 是一个类型的名字, 这类型用两个其他类型 \code{a} 和 \code{b} 参数化; \code{P}
是数据构造子的名字. 你把两个类型传给 \code{Pair} 类型构造子来定义一个对类型. 你把两个恰当类型的值传给
构造子 \code{P} 来构造一个对值. 例如, 我们定义一个值 \code{stmt} 为 \code{String} 和 \code{Bool} 的对:

\src{snippet10}
第一行是类型声明. 它在泛型的类型构造子 \code{Pair} 的定义中, 用 \code{String} 和 \code{Bool} 替换 \code{a} 和
\code{b}. 第二行定义了实际的值, 把一个具体的布尔和一个具体的字符串给数据构造子 \code{P}. 类型构造子用来构造类型;
数据构造子用来构造值.

因为类型构造子和数据构造子的命名空间是分开的, 你会经常看到同样的名字用在两者上, 就像:

\src{snippet11}
如果你仔细看, 你会发现内置的对类型就是这种声明的一种变体, 那里 \code{Pair} 换成了二元运算符 \code{(,)}.
其实你可以像其他具名的构造子一样用 \code{(,)} 来创建对, 用前缀表示法:

\src{snippet12}
同样的, 你可以用 \code{(,,)} 来创建三元组, 以此类推.

除了用泛型的对或者元组, 你也可以定义具名的积类型, 就像:

\src{snippet13}
这就是 \code{String} 和 \code{Bool} 之积, 但它有自己的名字和构造子. 这种风格的优势在于你可以定义很多类型, 它们有
相同的类型, 但是意思和功能不同, 所以不能互相替换.

编程用元组和多参数构造子可能会混乱和出错 --- 你要记住每个分量代表什么. 用具名的分量名字会更好. 一个有具名分量的积类型
在 Haskell 里叫\newterm{record (记录)}, 在 C 里叫\code{struct (结构)}.

\section{记录}

看一个简单的例子. 想要用一个数据结构表示化学元素, 其中有两个字符串---名称和符号; 还有一个整数代表原子序数. 可以用
元组 \code{(String, String, Int)} 来表示, 但是要记住每个分量代表什么. 用模式匹配提取分量, 像这个函数里检查元素
的符号是否为其名称的前缀(比如 \textbf{He} 是 \textbf{Helium} 的前缀):

\src{snippet14}
这段代码易错, 而且不可读不可维护. 定义一个记录会好很多:

\src{snippet15}
这两种表示是同构的, 有这两个转换函数, 它们是互逆的:

\src{snippet16}

\src{snippet17}
注意记录的名字同时是访问器函数. 例如, \code{atomicNumber e} 从 \code{e} 中取出 \code{atomicNumber} 字段.
我们把 \code{atomicNumber} 当作这个类型的函数:

\src{snippet18}
用 \code{Element} 的记录句法, 我们的函数 \code{startsWithSymbol} 变得更可读:

\src{snippet19}
我们甚至可以用 Haskell 的技巧, 把函数 \code{isPrefixOf} 变成中缀运算符, 使它读起来像句子:

\src{snippet20}
这里的括号可以省略, 因为中缀运算符的优先级比函数调用低.

\section{和类型}

正如集合范畴里的积产生了积类型, 余积运算给出了和类型. Haskell 中和类型的经典实现是:

\src{snippet21}
就像对, \code{Either}们是可交换的(同构意义上), 可以嵌套, 嵌套顺序无关(同构意义上).
所以我们可以定义三元的和类型:

\src{snippet22}
以此类推.

It turns out that $\Set$ is also a (symmetric) monoidal category
with respect to coproduct. The role of the binary operation is played by
the disjoint sum, and the role of the unit element is played by the
initial object. In terms of types, we have \code{Either} as the
monoidal operator and \code{Void}, the uninhabited type, as its
neutral element. You can think of \code{Either} as plus, and
\code{Void} as zero. Indeed, adding \code{Void} to a sum type
doesn't change its content. For instance:

\src{snippet23}
is isomorphic to \code{a}. That's because there is no way to construct
a \code{Right} version of this type --- there isn't a value of type
\code{Void}. The only inhabitants of \code{Either a Void} are
constructed using the \code{Left} constructors and they simply
encapsulate a value of type \code{a}. So, symbolically, $a + 0 = a$.

Sum types are pretty common in Haskell, but their C++ equivalents,
unions or variants, are much less common. There are several reasons for
that.

First of all, the simplest sum types are just enumerations and are
implemented using \code{enum} in C++. The equivalent of the Haskell
sum type:

\src{snippet24}
is the C++:

\begin{snip}{cpp}
enum { Red, Green, Blue };
\end{snip}
An even simpler sum type:

\src{snippet25}
is the primitive \code{bool} in C++.

Simple sum types that encode the presence or absence of a value are
variously implemented in C++ using special tricks and ``impossible''
values, like empty strings, negative numbers, null pointers, etc. This
kind of optionality, if deliberate, is expressed in Haskell using the
\code{Maybe} type:

\src{snippet26}
The \code{Maybe} type is a sum of two types. You can see this if you
separate the two constructors into individual types. The first one would
look like this:

\src{snippet27}
It's an enumeration with one value called \code{Nothing}. In other
words, it's a singleton, which is equivalent to the unit type
\code{()}. The second part:

\src{snippet28}
is just an encapsulation of the type \code{a}. We could have encoded
\code{Maybe} as:

\src{snippet29}
More complex sum types are often faked in C++ using pointers. A pointer
can be either null, or point to a value of specific type. For instance,
a Haskell list type, which can be defined as a (recursive) sum type:

\src{snippet30}
can be translated to C++ using the null pointer trick to implement the
empty list:

\begin{snip}{cpp}
template<class A>
class List {
    Node<A> * _head;
public:
    List() : _head(nullptr) {} // Nil
    List(A a, List<A> l)       // Cons
      : _head(new Node<A>(a, l))
    {}
};
\end{snip}
Notice that the two Haskell constructors \code{Nil} and \code{Cons}
are translated into two overloaded \code{List} constructors with
analogous arguments (none, for \code{Nil}; and a value and a list for
\code{Cons}). The \code{List} class doesn't need a tag to
distinguish between the two components of the sum type. Instead it uses
the special \code{nullptr} value for \code{\_head} to encode
\code{Nil}.

The main difference, though, between Haskell and C++ types is that
Haskell data structures are immutable. If you create an object using one
particular constructor, the object will forever remember which
constructor was used and what arguments were passed to it. So a
\code{Maybe} object that was created as \code{Just "energy"} will
never turn into \code{Nothing}. Similarly, an empty list will forever
be empty, and a list of three elements will always have the same three
elements.

It's this immutability that makes construction reversible. Given an
object, you can always disassemble it down to parts that were used in
its construction. This deconstruction is done with pattern matching and
it reuses constructors as patterns. Constructor arguments, if any, are
replaced with variables (or other patterns).

The \code{List} data type has two constructors, so the deconstruction
of an arbitrary \code{List} uses two patterns corresponding to those
constructors. One matches the empty \code{Nil} list, and the other a
\code{Cons}-constructed list. For instance, here's the definition of a
simple function on \code{List}s:

\src{snippet31}
The first part of the definition of \code{maybeTail} uses the
\code{Nil} constructor as pattern and returns \code{Nothing}. The
second part uses the \code{Cons} constructor as pattern. It replaces
the first constructor argument with a wildcard, because we are not
interested in it. The second argument to \code{Cons} is bound to the
variable \code{t} (I will call these things variables even though,
strictly speaking, they never vary: once bound to an expression, a
variable never changes). The return value is \code{Just t}. Now,
depending on how your \code{List} was created, it will match one of
the clauses. If it was created using \code{Cons}, the two arguments
that were passed to it will be retrieved (and the first discarded).

Even more elaborate sum types are implemented in C++ using polymorphic
class hierarchies. A family of classes with a common ancestor may be
understood as one variant type, in which the vtable serves as a hidden
tag. What in Haskell would be done by pattern matching on the
constructor, and by calling specialized code, in C++ is accomplished by
dispatching a call to a virtual function based on the vtable pointer.

You will rarely see \code{union} used as a sum type in C++ because of
severe limitations on what can go into a union. You can't even put a
\code{std::string} into a union because it has a copy constructor.

\section{Algebra of Types}

Taken separately, product and sum types can be used to define a variety
of useful data structures, but the real strength comes from combining
the two. Once again we are invoking the power of composition.

Let's summarize what we've discovered so far. We've seen two commutative
monoidal structures underlying the type system: We have the sum types
with \code{Void} as the neutral element, and the product types with
the unit type, \code{()}, as the neutral element. We'd like to think
of them as analogous to addition and multiplication. In this analogy,
\code{Void} would correspond to zero, and unit, \code{()}, to one.

Let's see how far we can stretch this analogy. For instance, does
multiplication by zero give zero? In other words, is a product type with
one component being \code{Void} isomorphic to \code{Void}? For
example, is it possible to create a pair of, say \code{Int} and
\code{Void}?

To create a pair you need two values. Although you can easily come up
with an integer, there is no value of type \code{Void}. Therefore, for
any type \code{a}, the type \code{(a, Void)} is uninhabited --- has
no values --- and is therefore equivalent to \code{Void}. In other
words, $a \times 0 = 0$.

Another thing that links addition and multiplication is the distributive
property:
\[a \times (b + c) = a \times b + a \times c\]
Does it also hold for product and sum types? Yes, it does --- up to
isomorphisms, as usual. The left hand side corresponds to the type:

\src{snippet32}
and the right hand side corresponds to the type:

\src{snippet33}
Here's the function that converts them one way:

\src{snippet34}
and here's one that goes the other way:

\src{snippet35}
The \code{case of} statement is used for pattern matching inside
functions. Each pattern is followed by an arrow and the expression to be
evaluated when the pattern matches. For instance, if you call
\code{prodToSum} with the value:

\src{snippet36}
the \code{e} in \code{case e of} will be equal to
\code{Left "Hi!"}. It will match the pattern \code{Left y},
substituting \code{"Hi!"} for \code{y}. Since the \code{x} has
already been matched to \code{2}, the result of the \code{case of}
clause, and the whole function, will be \code{Left (2, "Hi!")}, as
expected.

I'm not going to prove that these two functions are the inverse of each
other, but if you think about it, they must be! They are just trivially
re-packing the contents of the two data structures. It's the same data,
only different format.

Mathematicians have a name for two such intertwined monoids: it's called
a \newterm{semiring}. It's not a full \newterm{ring}, because we can't define
subtraction of types. That's why a semiring is sometimes called a
\newterm{rig}, which is a pun on ``ring without an \emph{n}'' (negative).
But barring that, we can get a lot of mileage from translating
statements about, say, natural numbers, which form a rig, to statements
about types. Here's a translation table with some entries of interest:

\begin{longtable}[]{@{}ll@{}}
  \toprule
  Numbers      & Types\tabularnewline
  \midrule
  \endhead
  $0$          & \code{Void}\tabularnewline
  $1$          & \code{()}\tabularnewline
  $a + b$      & \code{Either a b = Left a | Right b}\tabularnewline
  $a \times b$ & \code{(a, b)} or \code{Pair a b = Pair a b}\tabularnewline
  $2 = 1 + 1$  & \code{data Bool = True | False}\tabularnewline
  $1 + a$      & \code{data Maybe = Nothing | Just a}\tabularnewline
  \bottomrule
\end{longtable}

\noindent
The list type is quite interesting, because it's defined as a solution
to an equation. The type we are defining appears on both sides of the
equation:

\src{snippet37}
If we do our usual substitutions, and also replace \code{List a} with
\code{x}, we get the equation:

\begin{Verbatim}
  x = 1 + a * x
\end{Verbatim}
We can't solve it using traditional algebraic methods because we can't
subtract or divide types. But we can try a series of substitutions,
where we keep replacing \code{x} on the right hand side with
\code{(1 + a*x)}, and use the distributive property. This leads to
the following series:

\begin{Verbatim}
  x = 1 + a*x
  x = 1 + a*(1 + a*x) = 1 + a + a*a*x
  x = 1 + a + a*a*(1 + a*x) = 1 + a + a*a + a*a*a*x
  ...
  x = 1 + a + a*a + a*a*a + a*a*a*a...
\end{Verbatim}
We end up with an infinite sum of products (tuples), which can be
interpreted as: A list is either empty, \code{1}; or a singleton,
\code{a}; or a pair, \code{a*a}; or a triple, \code{a*a*a};
etc\ldots{} Well, that's exactly what a list is --- a string of
\code{a}s!

There's much more to lists than that, and we'll come back to them and
other recursive data structures after we learn about functors and fixed
points.

Solving equations with symbolic variables --- that's algebra! It's what
gives these types their name: algebraic data types.

Finally, I should mention one very important interpretation of the
algebra of types. Notice that a product of two types \code{a} and
\code{b} must contain both a value of type \code{a} \emph{and} a
value of type \code{b}, which means both types must be inhabited. A
sum of two types, on the other hand, contains either a value of type
\code{a} \emph{or} a value of type \code{b}, so it's enough if one
of them is inhabited. Logical \emph{and} and \emph{or} also form a
semiring, and it too can be mapped into type theory:

\begin{longtable}[]{@{}ll@{}}
  \toprule
  Logic                & Types\tabularnewline
  \midrule
  \endhead
  $\mathit{false}$     & \code{Void}\tabularnewline
  $\mathit{true}$      & \code{()}\tabularnewline
  $a \mathbin{||} b$   & \code{Either a b = Left a | Right b}\tabularnewline
  $a \mathbin{\&\&} b$ & \code{(a, b)}\tabularnewline
  \bottomrule
\end{longtable}

\noindent
This analogy goes deeper, and is the basis of the Curry-Howard
isomorphism between logic and type theory. We'll come back to it when we
talk about function types.

\section{Challenges}

\begin{enumerate}
  \tightlist
  \item
        Show the isomorphism between \code{Maybe a} and
        \code{Either () a}.
  \item
        Here's a sum type defined in Haskell:

        \begin{snip}{haskell}
data Shape = Circle Float
           | Rect Float Float
\end{snip}
        When we want to define a function like \code{area} that acts on a
        \code{Shape}, we do it by pattern matching on the two constructors:

        \begin{snip}{haskell}
area :: Shape -> Float
area (Circle r) = pi * r * r
area (Rect d h) = d * h
\end{snip}
        Implement \code{Shape} in C++ or Java as an interface and create two
        classes: \code{Circle} and \code{Rect}. Implement \code{area} as
        a virtual function.
  \item
        Continuing with the previous example: We can easily add a new function
        \code{circ} that calculates the circumference of a \code{Shape}.
        We can do it without touching the definition of \code{Shape}:

        \begin{snip}{haskell}
circ :: Shape -> Float
circ (Circle r) = 2.0 * pi * r
circ (Rect d h) = 2.0 * (d + h)
\end{snip}
        Add \code{circ} to your C++ or Java implementation. What parts of
        the original code did you have to touch?
  \item
        Continuing further: Add a new shape, \code{Square}, to
        \code{Shape} and make all the necessary updates. What code did you
        have to touch in Haskell vs. C++ or Java? (Even if you're not a
        Haskell programmer, the modifications should be pretty obvious.)
  \item
        Show that $a + a = 2 \times a$ holds for types (up to
        isomorphism). Remember that $2$ corresponds to \code{Bool},
        according to our translation table.
\end{enumerate}
