% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]
{范}畴实例可以让你欣赏范畴. 有各种形状和大小的范畴, 它们经常在意想不到的地方出现. 我们从最简单的例子开始.

\section{无物件}

最简单的范畴是无物件的范畴, 自然也没有态射. 这范畴好像很无聊, 但它在其它范畴的背景中或许有用. 例如, 在所有
范畴的范畴中(是的, 有这个). 如果你觉得空集有用, 那为什么不要空范畴呢?

\section{简单图}

你可以把物件用箭头连接起来. 这样就得到一个范畴. 从一个有向图开始, 添加更多的箭头, 就可以把它变成范畴. 首先,
在每个节点处增加一个单位箭头. 然后, 对任何两个首尾相连的箭头(\newterm{可组合箭头}), 添加一个新的箭头,
作为它们的组合. 每次加入新箭头的时候, 你都要考虑它和其它箭头的组合(单位箭头除外). 你通常会得到无限多的箭头, 但没关系.

换一种角度看这个过程. 你在创建一个范畴, 物件是图的每个节点, 态射是所有可组合图边的\newterm{Chain 链}.
(你甚至可以把单位态射看作长度为零的链.)

这种范畴叫做从一个图生成的 \newterm{free category 自由范畴}. 这个构造过程是一种自由构造, 就是向一个结构
中加入最少的元素, 使之成为符合新规则(在这里是范畴的规则)的一个结构. 未来会有更多例子.

\section{序}

接着来点完全不一样的! 这个范畴的态射是物件之间的关系: 小于等于. 让我们检查一下它是否确实是一个范畴. 有单位态射吗?
每个物件都小于等于自己: 当然! 有组合吗? 若 $a \leqslant b$ 且 $b \leqslant c$, 那么 $a \leqslant c$: 当然!
服从结合律吗? 当然! 这种关系叫做 \newterm{preorder 预序}, 所以预序集确实是范畴.

关系还可以更强一些, 需要一些额外条件. 若 $a \leqslant b$ 且 $b \leqslant a$, 那么 $a$ 必须和 $b$ 相等.
这种关系叫做\newterm{partial order 偏序}.

还可以要求任何两个物件之间都有关系, 要么正着, 要么反着. 这样就得到\newterm{linear order 线序}或
\newterm{total order 全序}关系.

把这些有序集合作为范畴来研究. 预序集合这个范畴里, 从任意物件 $a$ 到任何物件 $b$ 最多只有一个态射.
这种范畴叫做\newterm{thin 薄}范畴. 预序集合是薄范畴.

范畴 $\cat{C}$ 中从物件 $a$ 到物件 $b$ 的态射集合叫做\newterm{hom-set} $\cat{C}(a, b)$ (或者有时候写作
$\mathbf{Hom}_{\cat{C}}(a, b)$). 所以预序集合中的每个 hom-set 要么是空集, 要么是单例集合. 这包括
$\cat{C}(a, a)$, 从 $a$ 到 $a$ 的态射集合, 它必须是单例集合, 只包含单位态射. 但是, 你可以在预序集合中
有环. 环不能出现在偏序集中.

识别预序集合, 偏序集合和全序集合很重要, 因为排序. 排序算法, 例如快速排序, 冒泡排序, 归并排序等, 只能在全序集合上
正确工作. 偏序集合只能用拓扑排序.

\section{幺半群作为集合}

幺半群是一个非常简单却又非常强大的概念. 这概念隐藏在基本算数后面: 加法和乘法都形成幺半群. 幺半群在编程中无处不在.
它们出现在字符串, 列表, 可折叠数据结构, 并发编程中的 futures, 函数式响应式(reactive)编程中的事件等等.

传统来说, 幺半群是一个带有二元运算的集合. 这个运算必须满足结合律, 并且有一个特殊元素作为幺元.

例如, 含有零的自然数和加法运算形成一个幺半群. 结合律意味着:
\[(a + b) + c = a + (b + c)\]
(就是, 加法的时候不用括号)

幺元是零, 因为
\[0 + a = a\]
而且
\[a + 0 = a\]
第二个等式是多余的, 因为加法是交换的 $(a + b = b + a)$, 但交换不是幺半群的定义的一部分. 例如, 字符串拼接
不是交换的, 但它形成一个幺半群. 顺带一提, 字符串拼接的幺元是空字符串, 它附加到字符串的任一端都不改变它.

在 Haskell 中, 我们可以为幺半群定义一个类型类 --- 一个带有幺元\code{mempty}的类型, 以及一个
二元运算叫做\code{mappend}:

\src{snippet01}

函数有两个参数, 签名类型\code{m -> m -> m}一开始看起来有点奇怪. 讲过柯里化(currying)后, 它就会变得很清楚.
可以用两种方法解释带有多个箭头的签名: 作为多个参数的函数, 最右边的类型是返回类型; 或者作为一个参数的函数
(最左边的), 返回一个函数. 后一种解释可以用括号强调, 尽管括号是多余的(因为箭头是右结合的), 就像这样:
\code{m -> (m -> m)}. 一会儿我们会回来讨论这种解释.

注意 Haskell 没有办法表达幺半群的性质(即\code{mempty}是幺元, \code{mappend}是结合的).
需要程序员来确保它们满足这些性质.

Haskell 的类不像 C++ 那样具有侵入性. 定义一个新类型时, 你不必事先指定它的类. 你可以拖延, 后面再声明这类型
是某个类的实例. 例如, 让我们声明\code{String}是一个幺半群, 提供\code{mempty}和\code{mappend}的实现
(实际上, 这在标准库 Prelude 中已经做过了):

\src{snippet02}
这里我们重用 \code{(++)} 列表连接运算符, 因为 \code{String} 只是字符列表.

再说几句 Haskell 语法: 任何中缀运算符都可以用括号包围, 变成一个二元函数. 给定两个字符串, 你可以在中间
插入 \code{++} 来连接:

\begin{snip}{haskell}
"Hello " ++ "world!"
\end{snip}

或者把它们作为两个参数传给括号中的 \code{(++)}:

\begin{snip}{haskell}
(++) "Hello " "world!"
\end{snip}
注意函数的参数不是用逗号分隔的, 也不用括号包围. (这可能是学习 Haskell 时最难适应的事情.)

强调下, Haskell 允许你表达函数相等, 就像这样:

\begin{snip}{haskell}
mappend = (++)
\end{snip}
概念上, 这和表达函数的结果相同是不一样的. 那个是这样:

\begin{snip}{haskell}
mappend s1 s2 = (++) s1 s2
\end{snip}
前者看作范畴 $\Hask$(忽略不中止计算, 也就是 bottom 的话, $Set$) 中的态射相等. 这个等式不仅更简明,
而且还可以推广到其它范畴. 后者叫做\newterm{extension 外延}相等, 它断言对于任何两个输入字符串,
\code{mappend} 和 \code{(++)} 的输出相同. 参数的值有时被称为\newterm{point 点}(比如: $f$ 在点 $x$ 的值),
所以外延相等又可以叫做逐点相等. 与此相反, 前面不指名参数的相等是 \newterm{point-free 无点的}.
(顺便说一句, 无点等式经常涉及函数的组合, 函数组合的符号却是一个点, 初学者可能有点费解.)

用 C++ 20 的概念也可以在 C++ 中得到类似的幺半群定义:

\begin{snip}{cpp}
template<class T>
struct mempty;

template<class T>
T mappend(T, T) = delete;

template<class M>
concept Monoid = requires (M m) {
    { mempty<M>::value() } -> std::same_as<M>;
    { mappend(m, m) } -> std::same_as<M>;
};
\end{snip}
第一个定义是一个结构体, 用来保存每个特化的幺元.

关键字 \code{delete} 删除默认值: 每个情况下都必须手动特化. 所以, \code{mappend} 没有默认值.

概念 \code{Monoid} 测试对类型 \code{M} 是否存在适当的 \code{mempty} 和 \code{mappend} 定义.

只要写出合适的特化和重载, 就可以实例化 \code{Monoid} 概念:

\begin{snip}{cpp}
template<>
struct mempty<std::string> {
    static std::string value() { return ""; }
};

template<>
std::string mappend(std::string s1, std::string s2) {
    return s1 + s2;
}
\end{snip}

\section{幺半群作为范畴}

以上就是``熟悉的''集合论中的幺半群. 但你知道, 范畴论中我们要丢掉集合, 元素; 用物件和态射代替. 所以我们
换一个思路, 把二元运算看作``移动''或``转移''集合中的元素.

例如, 每个自然数对应一个 +5 的操作. 它把 0 映射到 5, 1 映射到 6, 2 映射到 7, 以此类推. 这是一个定义在
自然数集合上的函数. 好, 有一个函数, 有一个集合. 一般来说, 对于任何数 $n$, 都有一个加 $n$ 的函数 ---
$n$ 的``加法器''.

加法器怎么组合? 加 5 的函数与加 7 的函数的组合成加 12 的函数. 所以加法器的组合可以等价于加法的规则.
这也很好: 我们可以用函数组合来代替加法.

等等: 还有幺元的加法器, 零加法器. 加零不会移动元素, 所以它是自然数集合中的单位函数.

扔下传统的加法规则, 只用组合加法器的规则, 也没有任何问题. 注意加法器的组合服从结合律, 因为函数的组合
服从结合律. 而且我们还有零加法器, 这是个单位函数.

敏锐的读者也许已经发现, 从整数到加法器的映射遵循 \code{mappend} 的第二种解释, 即 \code{m -> (m -> m)}.
它告诉我们, \code{mappend} 把幺半群中的元素映射到作用在幺半群上的函数.

忘掉你在自然数集合上吧. 把它想成一个单一物件, 一个 blob, 有一堆态射 --- 加法器. 幺半群是一个单一物件的
范畴. 事实上, ``monoid'' 这个名字来自希腊语 \emph{mono}, 意思是单一. 每个幺半群都可以描述为一个单一物件
的范畴, 有一堆态射, 服从一些组合的规则.


\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/monoid.jpg}
\end{figure}

\noindent
字符串拼接是个有意思的例子, 因为需要考虑两种追加器: 左追加器(或者\emph{前追加器})和右追加器. 这两个模型的
组合表镜像相反. 在 ``foo'' 后追加 ``bar'' 就是 ``bar'' 前追加 ``foo''.

你也许会问, 是不是每个范畴幺半群 --- 一个一物件的范畴 --- 都能对应上一个用集合论定义的幺半群? \footnote{以加法
幺半群为例.自然数集合有无限元素, 而范畴只有一个物件. 这看上去有些奇怪, 元素和物件不是一一对应的吗? --译注}
答案是肯定的. 我们总可以从单物件范畴中提取一个集合, 这个集合是态射的集合 --- 我们的例子中是加法器.
换句话说, 在只有单一物件 $m$ 的范畴 $\cat{M}$ 中, 有一个 hom-集 $\cat{M}(m, m)$. 在这个集合上很容易
定义一个二元运算: 两个元素的幺半群积就是两个态射的组合. 给我两个 $\cat{M}(m, m)$ 中的元素, $f$ 和 $g$,
它们的积就是 $f \circ g$. 这个积总是存在的, 因为这两个态射的源和目标都是 $m$. 而且它是结合的, 因为
范畴的组合是结合的. 这个运算的幺元就是单位态射. 因此总可以从范畴论描述的幺半群中提取一个集合论描述的幺半群.
这两种方式都描述了相同的东西. 完全相同.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/monoidhomset.jpg}
  \caption{幺半群 hom-集 可以看作态射, 也可以看作集合中的点}
\end{figure}

\noindent
还剩下给数学家的一点小问题: 态射不必形成一个集合. 范畴论的世界里有比集合更大的东西. 一个范畴中, 若任意两个物件之
间的态射都形成一个集合, 称这个范畴\newterm{locally small 局部小}. 我确实说过会忽略这些细节, 但还是应该提一下.

范畴论中很多有趣的现象都源于这样一个事实: hom-集的元素既可以看作态射, 也可以看作集合中的点. 在范畴论中, 它服从组合
的规则. 这里, $\cat{M}$ 中的态射组合对应于 $\cat{M}(m, m)$ 中的幺半群积.

\section{挑战}

\begin{enumerate}
  \tightlist
  \item
        构造自由范畴:

        \begin{enumerate}
          \tightlist
          \item
                一个节点, 没有边的图.
          \item
                一个节点, 一条有向边的图. (提示: 这条边可以和自己组合)
          \item
                这个图有两个节点, 它们之间有一个箭头.
          \item
                这个图有一个节点. 26 个箭头, 分别标有字母 a, b, c \ldots{} z.
        \end{enumerate}
  \item
        这是什么序?

        \begin{enumerate}
          \tightlist
          \item
                有一个集合的集合. 这个集合上定义包含关系: $A$ 包含 $B$ 当 $A$ 中的每个元素也在 $B$ 中.
          \item
                C++ 类型上的子类型关系: \code{T1} 是 \code{T2} 的子类型, 当 \code{T1} 的指针可以传给
                期望 \code{T2} 指针的函数, 而不会触发编译错误.
        \end{enumerate}
  \item
        考虑 \code{Bool} 类型, 它有两个值 \code{True} 和 \code{False}. 证明它上面有两个幺半群, 分别
        用 \code{\&\&} (AND) 和 \code{||} (OR) 作为二元运算.
  \item
        用范畴来表示 \code{Bool} 上有 \code{AND} 运算的幺半群: 列出其态射和组合规则.
  \item
        把加法模 3 表示为一个幺半群.
\end{enumerate}
