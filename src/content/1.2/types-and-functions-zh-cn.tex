% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{类型}{和函数} 的范畴在编程中很重要, 所以要谈谈什么是类型和我们为什么需要类型.

\section{谁需要类型?}

静态类型 vs 动态类型, 强类型 vs 弱类型. 这方面的争论由来已久. 我用一个思想实验解释一下这些选择.
假设有一群猴子随机敲键盘写程序, 然后编译运行它们.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/img_1329.jpg}
\end{figure}

\noindent
如果用机器语言, 猴子打出的任何字节序列都会被接受运行. 但用高级语言, 编译器可以检测词法和语法错误, 这很好.
许多猴子吃不到香蕉, 但剩下的程序有可能更有用. 类型检查阻止了许多无意义的程序. 而且, 动态类型语言中, 类型
失配在运行时发现, 而在强类型静态语言里, 编译期就能发现类型失配. 很多不正确的程序还没运行就被扫除了.

问题是, 我们想让猴子开心, 还是想要正确的程序?

打字猴子实验的通常目标是写出莎士比亚全集. 在循环中加入拼写和语法检查器会大大提高概率. 类型检查器可以进一步
保证如果罗密欧已经是人类了, 就不能发芽或者在重力场中捕捉光子.

\section{类型和可组合性}

范畴论研究组合箭头. 但不是随意两个箭头都可以组合. 第一个箭头的目标物件和第二个箭头的源物件必须相同. 编程时
我们把一个函数的结果传给下一个函数. 如果第二个函数不能解读第一个函数出产的数据, 那么程序运行不了. 首尾两端
必须匹配才能组合. 语言的类型系统越强, 这个匹配就越容易描述和核对.

在我看来只有一个严肃论据, 可以用来反对强静态类型检查. 它说, 这也许会扫除一些语义上正确的程序. 实践中, 这种
情况很少, 而且每一种语言都有后门, 在必要的时候可以绕开类型系统. 连 Haskell 都有 \code{unsafeCoerce}.
但这种功能要谨慎使用. 卡夫卡的角色, 格里高尔绕开人类的类型系统, 变成了一只虫子. 结局如何, 众所周知.

我还常常听到别人说, 考虑类型系统让程序员太累了. 我同情你, 特别是写过 C++ 迭代器定义之后. 但是已经有新的技术,
叫做 \newterm{类型推断}, 它让编译器从语境中推理多数类型. 在 C++ 里, 你可以用 \code{auto} 声明变量, 编译器
会推出它的类型.

在 Haskell 里, 除了特殊情况, 类型记号完全可选. 程序员往往还是写它们, 因为它们表达许多代码的语义, 而且让编译错误
更容易理解. 惯例在 Haskell 中以设计类型启动项目.\sloppy{之后, 类型记号驱动实现, 同时成为编译器施加的注释.}

强静态类型常常成为借口, 用来逃避测试. 有时你听 Haskell 程序员说, ``如果它编译了, 它就是对的''. 当然,
类型正确的程序不见得就能输出正确的结果. 根据研究, 这种轻率态度导致 Haskell 不像一般人想的那样产出高质量
代码. 在商业化背景下, 修复 bug 的压力只能让质量差强人意. 这质量如何, 由软件开发的预算和用户忍受度决定,
同编程语言和编程方法没什么关系. 更好的标准是去度量多少项目拉进度跳票, 或者大砍功能.

至于说单元测试可以取代强类型. 考虑强类型语言中常见的重构流程: 改变函数的参数类型, 修复所有构建错误, 就够了.
在弱类型语言中, 函数参数类型改变后, 这个函数的所有调用点都要改. 你可以用单元测试来发现这些不匹配, 但测试
通常是概率的, 而不是确定的. 测试是证明的糟糕替代品.

\section{什么是类型}

简单直觉, 类型就是值的集合. 类型 \code{Bool} (记住, Haskell 中的具体类型以大写字母开头) 是 \code{True} 和
\code{False} 的两个元素的集合. 类型 \code{Char} 是所有 Unicode 字符的集合, 比如 \code{a} 或者 \code{ą}.

集合可以是有限的, 也可以是无限的. \code{String} 类型是 \code{Char} 的列表, 这是无限集合的例子.

我们声明 \code{x} 是 \code{Integer} 类型:

\src{snippet01}
等于说这是一个 Integer 集合中的元素.
\code{Integer} 在 Haskell 中是一个无限集合, 可以用来做任意精度的算术运算. 也有一个有限集合 \code{Int},
对应机器类型, 就像 C++ 中的 \code{int}.

说类型就是集合, 其实不太准确. 例如涉及循环定义的多态函数有问题, 集合论中也不允许出现所有集合的集合. 但已经说过,
我们不会死究数学. 还好有一个集合的范畴, 叫做 $\Set$, 我们就用它. 在 $\Set$ 中, 物件是集合, 态射(箭头)是函数.

$\Set$ 是一个特殊的范畴. 我们可以窥探它的物件, 从中得到启发. 例如, 其中有没有元素的空集合. 还有单元素的特殊集合.
函数将一个集合的元素映射到另一个集合的元素. 它可以将两个元素映射到一个元素, 但不能将一个元素映射到两个元素.单位函数
将集合的每个元素映射到它自己, 等等. 下面打算逐渐忘掉这些, 用纯范畴论的语言表达这些概念, 也就是用物件和箭头.

如果能说 Haskell 的类型就是集合, Haskell 的函数就是集合上的函数, 那就太好了. 但有个小问题: 数学函数不执行代码
--- 它就是一个解. Haskell 函数必须计算解. 如果解可以在有限步骤内得到, 那就没问题 --- 不论数字多大, 但有些
计算涉及递归, 或许就不会终止了. 我们不能排除不终止的函数, 因为判断终止性是不可判定的 --- 著名的停机问题. 所以
计算机科学家提出一个好主意, 或者说是一个大 Hack(你怎么看?), 就是把每个类型扩展一个特殊值, 叫做 \newterm{bottom},
用 \code{\_|\_} 表示, 或者 Unicode $\bot$. 这个 ``值'' 对应一个不终止的计算. 所以一个函数:

\src{snippet02}
可以返回 \code{True}, \code{False}, 或者 \code{\_|\_}; 后者意味着它永远不终止.

很有意思, 一旦接受 \code{\_|\_} 是类型系统的一部分, 就可以方便地把每个运行时错误都当作 \code{\_|\_}, 甚至允许
函数显式返回 \code{\_|\_}. 后者通常用 \code{undefined} 表示:

\src{snippet03}
这个定义是类型正确的, 因为 \code{undefined} 求值为 bottom, 它是任何类型的元素, 包括 \code{Bool}. 你甚至可以写:

\src{snippet04}
(没有 \code{x}) 因为 bottom 也是 \code{Bool -> Bool} 类型的成员.

会返回 bottom 的函数叫做 \newterm{partial}, 与之相对的是 \newterm{total} 函数, 它对每个可能的参数都返回有效结果.

因为存在 bottom, 所以 Haskell 类型与函数组成的范畴不是 $\Set$, 而是 $\Hask$. 这里很快要出现复杂的理论问题, 所以我
要就此打住. 从实用角度看, 忽略 bottom, 把 $\Hask$ 当作 $\Set$ 就行. \footnote{Nils Anders Danielsson,
  John Hughes, Patrik Jansson, Jeremy Gibbons, \href{http://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf}{
    Fast and Loose Reasoning is Morally Correct}. 这篇论文证明了在大多数情况下忽略 bottom 是合理的.}

\section{为什么我们需要数学模型?}

当程序员的都熟悉编程语言的词法和语法. 这些通常在语言规格的开头就介绍了. 语言规格却很难描述语言的语义; 要用更多页,
而且不算形式化, 也不完备. 这激发语言律师无尽的争论, 争论的结果: 一大批书籍专门讨论语言规格的细节.

语义确实可以被形式化工具描述. 但太复杂了, 只能用在简化的学术语言上, 而不是真实的工业语言. 一个叫做
\newterm{operational semantics(操作语义)} 的形式化工具描述了程序执行的机制. 它定义了一个解释器,
是形式化的, 不过也是理想化的. C++ 这类产业语言的语义通常用非形式化的操作推理描述, 像 ``抽象机''.

问题是用操作语义证明程序的性质很难. 要展示一个程序的性质, 你必须 ``运行'' 理想化的解释器.

程序员从来不证明正确性, 这无关紧要. 我们总 ``觉得'' 我们写的程序正确. 没人坐在键盘前面说, ``我随便写几行代码,
看看结果如何.'' 我们总觉得写的代码会做正确的事情, 得到正确的结果. 没这样倒是奇怪了. 这意味着我们确实在推理
我们的程序, 用脑中的解释器. 但是很难跟踪所有变量. 计算机擅长运行程序, 人类不擅长. 如果我们擅长, 就不需要计算机了.

但还有一个选择. 叫做 \newterm{denotational semantics(指称语义)}, 它基于数学. 在指称语义中, 每个编程结构都有
数学解释. 有了这个, 如果你想证明程序的性质, 只要证明一个数学定理就行了. 你也许觉得证明定理很难, 但在证明定理上人们知识丰富,
毕竟已经积累上千年了. 而且, 和专业数学家证明的定理相比, 我们编程时遇到的问题通常很简单而显然.

考虑下面的 Haskell 阶乘函数定义, Haskell 很适合指称语义:

\src{snippet05}
表达式 \code{[1..n]} 是一个从 \code{1} 到 \code{n} 的整数列表. 函数 \code{product} 计算列表中所有元素的乘积.
这和数学教科书中的阶乘定义一样. 与之对比 C 语言:

\begin{snip}{c}
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
\end{snip}
还用多说吗?

好吧, 我承认这有些取巧. 阶乘函数有直白的数学定义. 敏锐的读者也许会问: 数学模型怎么描述从键盘读取字符, 或者
通过网络发送数据包? 一直以来这都是个棘手的问题, 也是一个复杂的解释. 似乎指称语义不适合处理许多重要的任务,
而操作语义可以. 但是, 有了范畴论, 一切都变了. Eugenio Moggi 发现计算效果可以映射到 \newterm{monad(单子)}.
这是一个重要的发现, 不仅让指称语义重获新生, 也让纯函数式程序更易用, 同时也让传统编程方法有了新的视角. 之后有了
更多范畴论工具之后, 我回头再讲单子.

有了编程的数学模型, 就可以形式化证明程序是正确的. 对娱乐软件来说好像没用, 但如果故障的代价很高, 例如在人命关天
的医疗软件中, 你也许就想用 Haskell 标准库中的函数, 因为它们都证明了正确.

\section{纯函数和脏函数}

C++ 之类命令式语言的函数不是数学函数. 数学函数只是值到值的映射而已.

可以在任何编程语言中实现数学函数: 这个函数, 给定输入, 计算输出. 平方函数会把输入乘以自己, 每次都这样,
每次的结果都一样. 结果不会因月相而变.

另外, 计算数字平方也不会产生副作用, 例如给狗狗发零食. 做这种事的 ``函数'' 不能轻易建模为数学函数.

编程语言中, 把这样相同输入总是得到相同输出的函数叫做\newterm{pure functions 纯函数}. 在像
Haskell 的纯函数式语言中, 所有函数都是纯函数. 所以这些语言很容易有指称语义, 也很容易用数学模型描述.
其他语言也可以只用纯函数部分, 或者单独考虑副作用. 之后我们会看到, 单子让我们用纯函数就能模拟所有副作用.
所以我们只用数学函数也不会丢掉什么.

\section{类型举例}

意识到类型就是集合, 你就可以考虑一些奇怪的类型. 例如, 空集合对应什么类型? 不, 不是 C++ 的 \code{void},
虽然 \code{Void} 是 Haskell 中对空集合类型的记号. 这个类型没有任何值. 可以定义一个函数, 参数是 \code{Void},
但你调用不了它. 要调用它, 你必须提供一个 \code{Void} 类型的值, 但这个值没有. 至于这个函数返回什么, 没有约束,
随意, 反正也永远不会返回(因为不能调用). 换句话说, 这是个返回值多态的函数. Haskell 程序员给它起了个名字:

\src{snippet06}

(记住, \code{a} 是一个类型变量, 可以代表任何类型.) 这个名字不是巧合. 用叫做 Curry-Howard 同构的逻辑,
类型和函数有更深层的联系. 类型 \code{Void} 表示假, 函数 \code{absurd} 的类型对应那句话: 假蕴涵一切,
正如拉丁格言 ``ex falso sequitur quodlibet''.

接下来是单例集合对应的类型. 这个类型只能有一个值. 这个值就是 ``有''. 你可能还看不出来, 但这就是 C++
的 \code{void}. 想想这个类型的函数. 从 \code{void} 出发到 $A$ 的函数总是可以调用. 如果它是纯函数,
它总是返回相同的结果. 例如:

\begin{snip}{c}
int f44() { return 44; }
\end{snip}

你也许觉得这函数接受 ``无'', 但我们说过, 接受 ``无'' 的函数没法调用, 因为不存在 ``无'' 的值. 那这个函数
的参数到底是什么? 概念上, 它不过接受一个哑元, 这哑元只有一个实例, 所以我们不必显式地提及它. Haskell 中有个
符号代表它: 一个空的括号, \code{()}. 很巧(真是巧合吗?), 有了这个记号以后, C++ 和 Haskell 中的 void 函数
调用看起来一样. 另外, Haskell 喜欢简洁, 所以类型, 构造器, 单例唯一的值都用同一个符号 \code{()} 表示.
所以看这个 Haskell 函数:

\src{snippet07}

第一行声明 \code{f44} 接受类型 \code{()}, 读作 ``unit'', 返回 \code{Integer} 类型. 第二行定义 \code{f44},
模式匹配 unit 的唯一构造器, 也就是 \code{()}, 返回数字 44. 调用这个函数, 你必须提供 unit 值 \code{()}:

\begin{snip}{c}
f44 ()
\end{snip}

注意每一个 unit 的函数都等价于从目标类型中挑选一个元素(这里是挑选 \code{Integer} 44). 其实你可以
把 \code{f44} 看作数字 44 的另一种表示. 这是我们用函数(箭头)代替集合元素的例子. 从 unit 到任何类型 $A$
的函数和 $A$ 的元素一一对应.

那返回 \code{void}, 或者说返回 unit 的函数呢? 在 C++ 中, 这样的函数用于副作用, 但这不是恰当的数学函数.
返回 unit 的纯函数什么也不做: 它仅仅丢弃参数.

数学上说, 从集合 $A$ 到单元集合的函数把 $A$ 的每个元素映射到单例集合的唯一元素. 对每个 $A$
恰好有一个这样的函数. 这是在 \code{Integer} 上的这个函数.

\src{snippet08}
给它任意整数, 就会返回给你一个 unit. 为了简洁, Haskell 让你用通配符 \code{\_} 表示丢弃的参数.
这样你就不需要自己发明一个记号. 所以上面的可以重写为:

\src{snippet09}
留意, 这个函数的实现不仅不依赖于传给它的值, 甚至不依赖于参数的类型.

对任何类型都有同样的解析式, 这样的函数叫做参数多态的函数. 你可以用一个类型参数而非具体类型实现一族这样的函数.
我们如何称呼从任意类型映射到 unit 的函数呢? 当然是 \code{unit}:

\src{snippet10}
在 C++ 中你这样写这个函数:

\begin{snip}{cpp}
template<class T>
void unit(T) {}
\end{snip}
在类型的分类学中, 下一组是二元集合. 在 C++ 中, 这叫做 \code{bool}, 在 Haskell 中叫做 \code{Bool}.
区别是在 C++ 中, \code{bool} 是内建类型, 而在 Haskell 中, 它可以这样定义:

\src{snippet11}
(读法: \code{Bool} 是 \code{True} 或 \code{False}.) 原则上大家也可以用枚举在 C++ 中定义布尔类型.

\begin{snip}{cpp}
enum bool {
    true,
    false
};
\end{snip}

但是 C++ \code{enum} 其实是整数. 也可以用 C++11 的 \code{enum class}, 但是这样你必须用类名限定值,
例如 \code{bool::true} 和 \code{bool::false}, 何况每个文件都要包含相应的头文件.

从 \code{Bool} 出发的纯函数只是从目标类型中挑选两个元素, 一个对应 \code{True}, 一个对应 \code{False}.

映射到 \code{Bool} 的函数又叫做\newterm{predicate 谓词}. 例如, Haskell 库 \code{Data.Char} 里有很多谓词,
例如 \code{isAlpha} 或者 \code{isDigit}. 在 C++ 中有类似的库, 有 \code{isalpha} 和 \code{isdigit},
但是这些函数返回 \code{int} 而不是布尔值. 实际的谓词在 \code{std::ctype} 中定义, 有 \code{ctype::is(alpha, c)},
\code{ctype::is(digit, c)} 等等.

\section{挑战}

\begin{enumerate}
  \tightlist
  \item
        用你最喜欢的语言定义高阶函数(或者函数对象) \code{memoize}. 接受一个纯函数 \code{f} 作为参数, 返回一个
        函数, 它和 \code{f} 几乎一样, 除了它只调用原函数一次, 把结果存起来, 然后每次参数一样的调用都返回存储的结果.
        你可以通过观察性能来区分 memoized 和原函数. 例如, 试着 memoize 一个计算量很大的函数, 第一次调用时你要等
        很久, 但后面每次调用都会立即返回结果.
  \item
        用上面的函数记录一个标准库的随机函数. 它还能正常工作吗?
  \item
        许多随机数生成器用种子初始化. 实现一个函数, 接受一个种子, 调用随机数生成器, 返回结果. memoize 这个函数,
        看看会发生什么?
  \item
        下面这些 C++ 函数中, 哪些是纯函数? 尝试 memoize 它们, 看看调用多次会发生什么? 会不会有不同的结果?

        \begin{enumerate}
          \tightlist
          \item
                The factorial function from the example in the text.
          \item
                \begin{minted}{cpp}
std::getchar()
\end{minted}
          \item
                \begin{minted}{cpp}
bool f() {
    std::cout << "Hello!" << std::endl;
    return true;
}
\end{minted}
          \item
                \begin{minted}{cpp}
int f(int x) {
    static int y = 0;
    y += x;
    return y;
}
\end{minted}
        \end{enumerate}
  \item
        \code{Bool} 到 \code{Bool} 的函数有多少种? 你能实现吗?
  \item
        画一个范畴, 它的物件是 \code{Bool} 和 \code{()} (unit), 箭头是类型之间可以存在的函数.
        用函数名标记箭头.
\end{enumerate}
